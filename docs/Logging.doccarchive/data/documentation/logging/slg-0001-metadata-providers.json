{"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"paths":["\/documentation\/logging\/slg-0001-metadata-providers"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"metadata":{"roleHeading":"Article","modules":[{"name":"Logging"}],"title":"Metadata Providers","role":"article"},"hierarchy":{"paths":[["doc:\/\/Logging\/documentation\/Logging"]]},"identifier":{"url":"doc:\/\/Logging\/documentation\/Logging\/SLG-0001-metadata-providers","interfaceLanguage":"swift"},"kind":"article","abstract":[{"type":"text","text":"While global metadata attributes may be manually set on a "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" level, there’s currently no way of reliably providing contextual, automatically propagated, metadata when logging with swift-log."}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Authors","level":2,"type":"heading","text":"Authors"},{"inlineContent":[{"identifier":"https:\/\/github.com\/slashmo","isActive":true,"type":"reference"},{"text":", ","type":"text"},{"identifier":"https:\/\/github.com\/ktoso","isActive":true,"type":"reference"}],"type":"paragraph"},{"anchor":"Motivation","level":2,"type":"heading","text":"Motivation"},{"inlineContent":[{"type":"text","text":"To benefit from tools such as "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing"},{"type":"text","text":" it is necessary for libraries to make use of the trace information."}],"type":"paragraph"},{"inlineContent":[{"text":"Most notably, loggers should participate in tracing by including some trace metadata (such as e.g. a ","type":"text"},{"code":"trace-id","type":"codeVoice"},{"text":") when logging, as it transparently enables developers to benefit from log correlation using those IDs.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Today, the only supported way of providing such metadata is to pass them along to each log call explicitly:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["logger.info(\"first this ...\", metadata: [\"trace-id\": MyTracingLibrary.currentTraceID])","logger.info(\"... now this\", metadata: [\"trace-id\": MyTracingLibrary.currentTraceID])"]},{"inlineContent":[{"type":"text","text":"This comes with a couple of downsides:"}],"type":"paragraph"},{"anchor":"Error-prone-and-repetitive","level":3,"type":"heading","text":"Error-prone and repetitive"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s easy to forget passing this metadata to "},{"inlineContent":[{"type":"text","text":"all"}],"type":"emphasis"},{"type":"text","text":" log statements, resulting in an inconsistent debugging experience as these log statements cannot be found using correlation IDs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The repetitiveness and verboseness of logging multiple metadata in-line quickly becomes annoying and vastly decreases the signal-to-noise ratio of Swift code trying to be a good citizen and making use of log correlation techniques such as distributed tracing."}]},{"type":"heading","level":3,"anchor":"Impossible-to-implement-for-libraries","text":"Impossible to implement for libraries"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A large portion of logs are not generated by the end-user but by libraries such as AsyncHTTPClient, Vapor etc."},{"type":"text","text":" "},{"type":"text","text":"These libraries, by design, don’t know about the specific metadata keys that should be included in the logs."},{"type":"text","text":" "},{"type":"text","text":"Those keys are after all runtime dependent, and may change depending on what tracing system is configured by the end user."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, a specific "},{"type":"codeVoice","code":"Tracer"},{"type":"text","text":" implementation would use a type representing a trace ID, and has a way of extracting"},{"type":"text","text":" "},{"type":"text","text":"that trace ID from a "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing-baggage"},{"type":"text","text":". But other libraries can’t know about this "},{"inlineContent":[{"type":"text","text":"specific"}],"type":"emphasis"},{"type":"text","text":" trace ID and therefore would not be"},{"type":"text","text":" "},{"type":"text","text":"able to pass such values along to their log statements."}]},{"type":"heading","level":2,"anchor":"Proposed-solution","text":"Proposed solution"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To support this kind of runtime-generated metadata in "},{"type":"codeVoice","code":"swift-log"},{"type":"text","text":", we need to extend the logging APIs in an open-ended way, to allow any kinds of metadata to be provided from the asynchronous context (i.e. task local values)."}]},{"type":"paragraph","inlineContent":[{"text":"We also have a desire to keep ","type":"text"},{"type":"codeVoice","code":"swift-log"},{"type":"text","text":" a “zero dependencies” library, as it intends only to focus on describing a logging API, and not incur any additional dependencies, so it can be used in the most minimal of projects."}]},{"type":"paragraph","inlineContent":[{"text":"To solve this, we propose the extension of swift-log APIs with a new concept: ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"metadata providers","type":"text"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"code":"MetadataProvider","type":"codeVoice"},{"text":" is a struct nested in the ","type":"text"},{"type":"codeVoice","code":"Logger"},{"type":"text","text":" type, sitting alongside "},{"type":"codeVoice","code":"MetadataValue"},{"text":" and the ","type":"text"},{"type":"codeVoice","code":"Metadata"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Its purpose is to "},{"inlineContent":[{"type":"text","text":"provide"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"codeVoice","code":"Logger.Metadata"},{"type":"text","text":" from the asynchronous context, by e.g. looking up various task-local values,"},{"text":" ","type":"text"},{"text":"and converting them into ","type":"text"},{"type":"codeVoice","code":"Logger.Metadata"},{"text":". This is performed by calling the ","type":"text"},{"type":"codeVoice","code":"get()"},{"type":"text","text":" function, like so:"}]},{"type":"codeListing","code":["extension Logger {","    public struct MetadataProvider: Sendable {","        \/\/ ... ","        public init(_ provideMetadata: @escaping @Sendable () -> Metadata)","    ","        public get() -> Metadata","    }","}"],"syntax":"swift"},{"type":"heading","level":3,"anchor":"Defining-a-MetadataProvider","text":"Defining a `MetadataProvider`"},{"type":"paragraph","inlineContent":[{"type":"text","text":"While "},{"code":"MetadataProvider","type":"codeVoice"},{"text":"s can be created in an ad-hoc fashion, the struct may be used as a namespace","type":"text"},{"text":" ","type":"text"},{"text":"to define providers in.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, a "},{"type":"codeVoice","code":"MyTracer"},{"type":"text","text":" implementation of swift-distributed-tracing would be expected to provide a metadata provider"},{"type":"text","text":" "},{"type":"text","text":"that is aware of its own "},{"type":"codeVoice","code":"Baggage"},{"text":" and specific keys it uses to carry the trace and span identifiers, like this:","type":"text"}]},{"syntax":"swift","code":["import Tracing \/\/ swift-distributed-tracing","","extension Logger.MetadataProvider {","    static let myTracer = Logger.MetadataProvider {","        guard let baggage = Baggage.current else {","            return [:]","        }","        guard let spanContext = baggage.spanContext else { ","            return [:]","        }","        ","        return [","          \"traceID\": \"\\(spanContext.traceID)\",","          \"spanID\": \"\\(spanContext.spanID)\",","        ]","    }","}"],"type":"codeListing"},{"type":"heading","anchor":"Using-a-MetadataProvider","level":3,"text":"Using a `MetadataProvider`"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"MetadataProvider","type":"codeVoice"},{"type":"text","text":" can be set up either globally, on a boot-strapped logging system:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["LoggingSystem.bootstrap(","    metadataProvider: .myTracer,","    StreamLogHandler.standardOutput",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"or, using the metadata provider specific bootstrap method:"}]},{"code":["LoggingSystem.bootstrapMetadataProvider(.myTracer)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is also possible to configure a metadata provider on a per-logger basis, like this:"}]},{"code":["let logger = Logger(label: \"example\", metadataProvider: Logger.MetadataProvider { ","    guard let baggage = Baggage.current else {","        return [:]","    }","    guard let operationID = baggage.operationID else { ","        return nil","    }","    return [\"extra\/opID\": \"\\(opID)\"]","})"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"which ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"overrides"}]},{"text":" the default bootstrapped metadata provider.","type":"text"}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Setting the metadata provider on the logger directly means the "},{"type":"codeVoice","code":"LoggingSystem"},{"type":"text","text":" metadata provider"},{"type":"text","text":" "},{"type":"text","text":"is skipped (if defined), following how an explicitly passed handler "},{"type":"codeVoice","code":"factory"},{"type":"text","text":" "},{"type":"text","text":"overrides the "},{"type":"codeVoice","code":"LoggingSystem"},{"text":"s ","type":"text"},{"code":"factory","type":"codeVoice"},{"type":"text","text":"."}]}],"name":"Note","style":"note"},{"inlineContent":[{"text":"Once a metadata provider was set up, when a log statement is about to be emitted, the log handler implementation shall","type":"text"},{"type":"text","text":" "},{"text":"invoke it whenever it is about to emit a log statement. This must be done from the same asynchronous context as the log statement","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"was made; I.e. if a log handler were to asynchronously–in a "},{"inlineContent":[{"text":"detached","type":"text"}],"type":"emphasis"},{"type":"text","text":" task–create the actual log message, the invocation of"},{"type":"text","text":" "},{"type":"text","text":"the metadata provider still "},{"type":"emphasis","inlineContent":[{"type":"text","text":"must"}]},{"text":" be performed before passing the data over to the other detached task.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Usually, metadata providers will reach for the task’s Swift Distributed Tracing "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing-baggage","overridingTitle":"Baggage","isActive":true,"overridingTitleInlineContent":[{"code":"Baggage","type":"codeVoice"}]},{"text":" which is the mechanism that swift-distributed-tracing","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and instrumentation libraries use to propagate metadata across asynchronous, as well as process, boundaries. Handlers"},{"type":"text","text":" "},{"text":"may also inspect other task-local values, however they should not expect other libraries to be able to propagage those","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as well as they will propagate "},{"type":"codeVoice","code":"Baggage"},{"type":"text","text":" values."}],"type":"paragraph"},{"inlineContent":[{"text":"Those metadata will then be included in the log statement, e.g. like this:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var baggage = Baggage.topLevel","baggage.spanContext = SpanContext()","Baggage.withValue(baggage) {","    test()","}","","func test() {","    log.info(\"Test\", metadata: [\"oneOff\": \"42\"])","    \/\/ info [traceID: abc, spanID: 123, onOff: 42] Test","}"]},{"level":3,"text":"Multiple `MetadataProvider`s using `MetadataProvider.multiplex(_:)`","anchor":"Multiple-MetadataProviders-using-MetadataProvidermultiplex","type":"heading"},{"inlineContent":[{"type":"text","text":"Borrowing the concept from log handlers, metadata providers also have a multiplexing implementation."},{"type":"text","text":" "},{"type":"text","text":"It is defined as an extension on "},{"type":"codeVoice","code":"MetadataProvider"},{"text":" and is useful in cases where users want to utilize","type":"text"},{"type":"text","text":" "},{"type":"text","text":"more than one metadata provider at the same time:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension Logger.MetadataProvider {","    public static func multiplex(_ providers: [Logger.MetadataProvider]) -> Logger.MetadataProvider {","        precondition(!providers.isEmpty, \"providers MUST NOT be empty\")","        return Logger.MetadataProvider { baggage in","            providers.reduce(into: nil) { metadata, provider in","                if let providedMetadata = provider.metadata(baggage) {","                    if metadata != nil {","                        metadata!.merge(providedMetadata, uniquingKeysWith: { _, rhs in rhs })","                    } else {","                        metadata = providedMetadata","                    }","                }","            }","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Metadata keys are unique, so in case multiple metadata providers return the same key,"},{"text":" ","type":"text"},{"type":"text","text":"the last provider in the array "},{"inlineContent":[{"text":"wins","type":"text"}],"type":"emphasis"},{"type":"text","text":" and provides the value."}]},{"type":"paragraph","inlineContent":[{"text":"Note that it is possible to query the ","type":"text"},{"type":"codeVoice","code":"LoggingSystem"},{"text":" for the configured, system-wide, metadata provider,","type":"text"},{"text":" ","type":"text"},{"text":"and combine it using a ","type":"text"},{"type":"codeVoice","code":"multiplex"},{"type":"text","text":" provider if the system-wide provider should not be replaced, but augmented"},{"type":"text","text":" "},{"type":"text","text":"by additional providers."}]},{"type":"heading","level":3,"text":"Understanding Swift Distributed Tracing `Baggage`","anchor":"Understanding-Swift-Distributed-Tracing-Baggage"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Baggage"},{"text":" type is more than just a fancy type-safe container for your values which are meant to be carried across","type":"text"},{"text":" ","type":"text"},{"text":"using a single, well-known, ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/tasklocal","type":"reference","isActive":true},{"type":"text","text":"."}]},{"inlineContent":[{"text":"Values stored in ","type":"text"},{"code":"Baggage","type":"codeVoice"},{"text":" are intended to be carried ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"across process boundaries"}]},{"type":"text","text":", and e.g. libraries such as HTTP clients,"},{"text":" ","type":"text"},{"type":"text","text":"or other RPC mechanisms, or even messaging systems implement distributed tracing "},{"identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing\/blob\/main\/Sources\/Instrumentation\/Instrument.swift","type":"reference","isActive":true},{"type":"text","text":""},{"text":" ","type":"text"},{"type":"text","text":"which "},{"type":"codeVoice","code":"inject"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"extract"},{"type":"text","text":" baggage values into their respective carrier objects, e.g. an "},{"type":"codeVoice","code":"HTTPRequest"},{"type":"text","text":" in the case of an HTTP client."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In other words, whenever intending to propagate information "},{"inlineContent":[{"text":"across processes","type":"text"}],"type":"emphasis"},{"type":"text","text":" utilize the "},{"code":"Baggage","type":"codeVoice"},{"text":" type to carry it,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and ensure to provide an "},{"type":"codeVoice","code":"Instrument"},{"type":"text","text":" that is able to inject\/extract the values of interest into the carrier types you are interested in."},{"type":"text","text":" "},{"type":"text","text":"To learn more about baggage and instrumentation, refer to the "},{"identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing\/","type":"reference","isActive":true},{"type":"text","text":" library documentation."}],"type":"paragraph"},{"type":"heading","text":"When to use `Baggage` vs. `Logger[metadataKey:]`","anchor":"When-to-use-Baggage-vs-LoggermetadataKey","level":4},{"type":"paragraph","inlineContent":[{"text":"While ","type":"text"},{"code":"Baggage","type":"codeVoice"},{"text":" is context-dependent and changes depending on where the log methods are being called from, the metadata set on a ","type":"text"},{"type":"codeVoice","code":"Logger"},{"text":" is static and not context-dependent. E.g, if you wanted to add things like an instance ID or a subsystem name to a ","type":"text"},{"code":"Logger","type":"codeVoice"},{"text":", that could be seen as static information and set via ","type":"text"},{"code":"Logger[metadataKey:]","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"codeListing","code":["var logger = Logger(label: \"org.swift.my-service\")","logger[metadataKey: \"instanceId\"] = \"123\"","","logger.info(\"Service started.\")","\/\/ [instanceId: 123] Service started."],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"On the other hand, things like a trace ID are dynamic and context-dependent, therefore would be obtained via ","type":"text"},{"code":"Baggage","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","code":["logger.info(\"Product fetched.\")","\/\/ [traceId: 42] Product fetched."],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Inline-metadata is suitable for one-offs such as a "},{"type":"codeVoice","code":"productId"},{"type":"text","text":" or a "},{"type":"codeVoice","code":"paymentMethod"},{"type":"text","text":" in an online store service, but are not enough to corralate the following log statements, i.e. tying them both to the same request:"}],"type":"paragraph"},{"code":["logger.info(\"Product fetched.\", metadata: [\"productId\": \"42\"])","logger.info(\"Product purchased.\", metadata: [\"paymentMethod\": \"apple-pay\"])","","\/\/ [productId: 42] Product fetched.","\/\/ [paymentMethod: apple-pay] Product fetched."],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If there was a "},{"type":"codeVoice","code":"Baggage"},{"type":"text","text":" value with a trace ID surrounding these log statements, they would be automatically correlatable:"}],"type":"paragraph"},{"syntax":"swift","code":["var baggage = Baggage.topLevel","baggage.traceID = 42","Baggage.$current.withValue(baggage) {","    logger.info(\"Product fetched.\", metadata: [\"productId\": \"42\"])","    logger.info(\"Product purchased.\", metadata: [\"paymentMethod\": \"apple-pay\"])","}","","\/\/ [trace-id: 42, productId: 42] Product fetched.","\/\/ [trace-id: 42, paymentMethod: apple-pay] Product fetched."],"type":"codeListing"},{"type":"heading","text":"Alternatives considered","anchor":"Alternatives-considered","level":2},{"level":3,"type":"heading","anchor":"MetadataProviders-as-a-function-of-Baggage-%3E-Metadata","text":"MetadataProviders as a function of `Baggage -> Metadata`"},{"inlineContent":[{"type":"text","text":"This was considered and fully developed, however it would cause swift-log to have a dependency on the instrumentation type "},{"type":"codeVoice","code":"Baggage"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which was seen as in-conflict-with the interest of swift-log remaining a zero-dependency library."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"Baggage"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"is"}]},{"type":"text","text":" the well known type that is intended to be used for any kind of distributed systems instrumentation and tracing,"},{"type":"text","text":" "},{"text":"however it adds additional complexity and confusion for users who are not interested in this domain. For example, developers","type":"text"},{"type":"text","text":" "},{"type":"text","text":"may be confused about why "},{"type":"codeVoice","code":"Baggage"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Logger.Metadata"},{"type":"text","text":" look somewhat similar, but behave very differently. This complexity"},{"type":"text","text":" "},{"type":"text","text":"is inherent to the two types actually being "},{"type":"emphasis","inlineContent":[{"type":"text","text":"very"}]},{"type":"text","text":" different, however we do not want to overwhelm newcomers or developers"},{"type":"text","text":" "},{"type":"text","text":"who are only intending to use swift-log within process. Such developers do not need to care about the added complexities"},{"type":"text","text":" "},{"type":"text","text":"of distributed systems."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The tradeoff we take here is that every metadata provider will have to perform its own task-local (and therefore also thread-local),"},{"type":"text","text":" "},{"type":"text","text":"access in order to obtain the "},{"type":"codeVoice","code":"Baggage"},{"type":"text","text":" value, rather than the lookup being able to be performed "},{"type":"emphasis","inlineContent":[{"text":"once","type":"text"}]},{"type":"text","text":" and shared between"},{"type":"text","text":" "},{"type":"text","text":"multiple providers when a multiplex provider was configured in the system. We view this tradeoff as worth taking, as the cost"},{"type":"text","text":" "},{"type":"text","text":"of actually formatting the metadata usually strongly dominates the cost of the task-local lookup."}]},{"type":"heading","anchor":"Removing-LogHandlerMetadata-in-favor-of-Baggage","level":3,"text":"Removing `LogHandler.Metadata` in favor of `Baggage`"},{"type":"paragraph","inlineContent":[{"text":"Removing logger metadata is not a good option because it serves a slightly different style of metadata than the baggage.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Baggage is intended for contextual, task-local, metadata which is "},{"type":"emphasis","inlineContent":[{"type":"text","text":"carried across multiple libraries"}]},{"type":"text","text":". The values stored in baggage are well-typed, and must declare keys for accessing values in a baggage, this works well for multiple pieces of an application needing to reach for specific baggage items: everyone aware of the "},{"type":"codeVoice","code":"traceID"},{"type":"text","text":" key, is able to query the baggage for this key ("},{"type":"codeVoice","code":"baggage.traceID"},{"type":"text","text":") and obtain a well-typed value. This comes with a higher cost on declaring keys though, as well as a global namespace for those - which is desirable for such kinds of metadata."}]},{"type":"paragraph","inlineContent":[{"text":"This is not the same usage pattern as emitting a plain structured log where we’d like to include the name of an item we just queried:","type":"text"}]},{"type":"codeListing","code":["log.info(\"Obtained item! Hooray!\", metadata: [\"item\": \"\\(item)\"])"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In this example, the key\/value pair for ","type":"text"},{"code":"\"item\"","type":"codeVoice"},{"text":" is pretty ad-hoc, and we never need to refer to it elsewhere in the program. It never is queried by other pieces of the application, nor would it be useful to set it in baggage metadata, as the only purpose of the ","type":"text"},{"code":"item","type":"codeVoice"},{"text":" key here is to log, and forget about it.","type":"text"}]},{"anchor":"Explicitly-passing-Baggage-always","type":"heading","level":3,"text":"Explicitly passing `Baggage` always"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Baggage is designed for use cases like distributed tracing, or similar instrumentation patterns where “all” participating code may need to reach for it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Specifically in logging, this means that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"every"}]},{"text":" call site for ","type":"text"},{"inlineContent":[{"type":"text","text":"every"}],"type":"emphasis"},{"text":" log statement would have to pass it explicitly resulting in annoying noisy code:","type":"text"}]},{"code":["class StoresRepository {","    func store(byID id: String, eventLoop: EventLoop, logger: Logger, baggage: Baggage) async throws -> Store {","        InstrumentationSystem.tracer.withSpan(\"Fetch Store\") { span in","            logger.info(\"Fetched store.\", baggage: span.baggage)","        }","    }","}","","try await storesRepository.store(","    byID: storeID,","    eventLoop: eventLoop,","    logger: logger,","    baggage: baggage",")"],"type":"codeListing","syntax":"swift"},{"anchor":"Explicitly-passing-Logger-always","text":"Explicitly passing `Logger` always","type":"heading","level":3},{"inlineContent":[{"text":"Imagine we don’t have metadata providers, we’d have to manually set trace IDs on loggers which doesn’t really work as all libraries involved would need to know about the same specific trace ID. Even if we inverted the dependency to have ","type":"text"},{"type":"codeVoice","code":"Tracing"},{"type":"text","text":" depend on "},{"type":"codeVoice","code":"Logging"},{"type":"text","text":" so that we’d be able to define something like “Tracing, please populate this logger with metadata”, we’d have to make sure this thing is called in all places to avoid dropping contextual metadata."}],"type":"paragraph"},{"syntax":"swift","code":["import Tracing","import Logging","","let contextualLogger = InstrumentationSystem.tracer.populateTraceMetadata(logger)","contextualLogger.info(\"Request received.\")"],"type":"codeListing"},{"level":3,"text":"Tracing providing extensions on Logger","anchor":"Tracing-providing-extensions-on-Logger","type":"heading"},{"inlineContent":[{"text":"Instead of having ","type":"text"},{"code":"swift-log","type":"codeVoice"},{"text":" depend on ","type":"text"},{"code":"swift-distributed-tracing-baggage","type":"codeVoice"},{"type":"text","text":" we could also create extensions for "},{"code":"Logger","type":"codeVoice"},{"type":"text","text":" inside "},{"code":"swift-distributed-tracing","type":"codeVoice"},{"type":"text","text":" and have users call these new overloaded methods instead:"}],"type":"paragraph"},{"type":"codeListing","code":["extension Logger {","    func tinfo(_ message: ..., baggage: Baggage?) {","        \/\/ ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Such extensions could work like the currently-proposed APIs, but the risk of users calling the wrong methods is incredibly high and we cannot overload the existing methods’ signatures because of ambiguity of call-sides without explicit Baggage being passed:"}]},{"syntax":"swift","code":["logger.info(\"Hello\")","\/\/ we want this to pick up Baggage, but the signature would be ambiguous"],"type":"codeListing"},{"inlineContent":[{"text":"Also, this extension-based contextual metadata would require basically everyone in Server-side Swift to adapt their usage of ","type":"text"},{"code":"Logging","type":"codeVoice"},{"type":"text","text":" to use these extensions instead. With the proposed APIs, we’d only need to modify "},{"code":"Logging","type":"codeVoice"},{"type":"text","text":" and any NIO-based libraries such as "},{"code":"AsyncHTTPClient","type":"codeVoice"},{"type":"text","text":", "},{"code":"Vapor","type":"codeVoice"},{"text":", etc. and not every single log statement in every application.","type":"text"}],"type":"paragraph"}]}],"references":{"https://github.com/apple/swift-distributed-tracing/":{"url":"https:\/\/github.com\/apple\/swift-distributed-tracing\/","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing\/","titleInlineContent":[{"type":"text","text":"Swift Distributed Tracing"}],"title":"Swift Distributed Tracing","type":"link"},"https://github.com/slashmo":{"url":"https:\/\/github.com\/slashmo","type":"link","identifier":"https:\/\/github.com\/slashmo","title":"Moritz Lang","titleInlineContent":[{"type":"text","text":"Moritz Lang"}]},"https://github.com/ktoso":{"identifier":"https:\/\/github.com\/ktoso","titleInlineContent":[{"type":"text","text":"Konrad ‘ktoso’ Malawski"}],"url":"https:\/\/github.com\/ktoso","type":"link","title":"Konrad ‘ktoso’ Malawski"},"doc://Logging/documentation/Logging":{"role":"collection","kind":"symbol","title":"Logging","abstract":[{"type":"text","text":"A unified, performant, and ergonomic logging API for Swift."}],"identifier":"doc:\/\/Logging\/documentation\/Logging","url":"\/documentation\/logging","type":"topic"},"https://github.com/apple/swift-distributed-tracing/blob/main/Sources/Instrumentation/Instrument.swift":{"url":"https:\/\/github.com\/apple\/swift-distributed-tracing\/blob\/main\/Sources\/Instrumentation\/Instrument.swift","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing\/blob\/main\/Sources\/Instrumentation\/Instrument.swift","titleInlineContent":[{"type":"text","text":"instruments"}],"title":"instruments","type":"link"},"https://github.com/apple/swift-distributed-tracing-baggage":{"url":"https:\/\/github.com\/apple\/swift-distributed-tracing-baggage","type":"link","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing-baggage","title":"Swift Distributed Tracing Baggage","titleInlineContent":[{"type":"text","text":"Swift Distributed Tracing Baggage"}]},"https://developer.apple.com/documentation/swift/tasklocal":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/tasklocal","titleInlineContent":[{"type":"text","text":"task-local value"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/tasklocal","type":"link","title":"task-local value"},"https://github.com/apple/swift-distributed-tracing":{"url":"https:\/\/github.com\/apple\/swift-distributed-tracing","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing","titleInlineContent":[{"type":"text","text":"Distributed Tracing"}],"title":"Distributed Tracing","type":"link"}}}