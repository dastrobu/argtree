{"sections":[],"identifier":{"url":"doc:\/\/Logging\/documentation\/Logging\/ImplementingALogHandler","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/Logging\/documentation\/Logging"]]},"abstract":[{"type":"text","text":"Create a custom logging backend that provides logging services for your apps and libraries."}],"seeAlsoSections":[{"identifiers":["doc:\/\/Logging\/documentation\/Logging\/LogHandler","doc:\/\/Logging\/documentation\/Logging\/StreamLogHandler","doc:\/\/Logging\/documentation\/Logging\/MultiplexLogHandler"],"title":"Related Documentation","anchor":"Related-Documentation"},{"anchor":"Best-Practices","identifiers":["doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices"],"title":"Best Practices","generated":true}],"metadata":{"role":"article","title":"Implementing a log handler","modules":[{"name":"Logging"}],"roleHeading":"Article"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/logging\/implementingaloghandler"]}],"kind":"article","schemaVersion":{"patch":0,"minor":3,"major":0},"primaryContentSections":[{"content":[{"type":"heading","level":2,"anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"To become a compatible logging backend that any SwiftLog consumer can use,","type":"text"},{"text":" ","type":"text"},{"text":"you need to fulfill a few requirements, primarily conforming to the","type":"text"},{"text":" ","type":"text"},{"identifier":"doc:\/\/Logging\/documentation\/Logging\/LogHandler","isActive":true,"type":"reference"},{"text":" protocol.","type":"text"}]},{"type":"heading","level":3,"anchor":"Implement-with-value-type-semantics","text":"Implement with value type semantics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Your log handler "},{"type":"strong","inlineContent":[{"text":"must be a ","type":"text"},{"code":"struct","type":"codeVoice"}]},{"type":"text","text":" and exhibit value semantics. This"},{"type":"text","text":" "},{"type":"text","text":"ensures that changes to one logger don’t affect others."}]},{"type":"paragraph","inlineContent":[{"text":"To verify that your handler reflects value semantics ensure that it passes this","type":"text"},{"text":" ","type":"text"},{"text":"test:","type":"text"}]},{"type":"codeListing","code":["@Test","func logHandlerValueSemantics() {","    LoggingSystem.bootstrap(MyLogHandler.init)","    var logger1 = Logger(label: \"first logger\")","    logger1.logLevel = .debug","    logger1[metadataKey: \"only-on\"] = \"first\"","    ","    var logger2 = logger1","    logger2.logLevel = .error                  \/\/ Must not affect logger1","    logger2[metadataKey: \"only-on\"] = \"second\" \/\/ Must not affect logger1","    ","    \/\/ These expectations must pass","    #expect(logger1.logLevel == .debug)","    #expect(logger2.logLevel == .error)","    #expect(logger1[metadataKey: \"only-on\"] == \"first\")","    #expect(logger2[metadataKey: \"only-on\"] == \"second\")","}"],"syntax":"swift"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In special cases, it is acceptable for a log handler to provide"},{"type":"text","text":" "},{"type":"text","text":"global log level overrides that may affect all log handlers created."}]}],"style":"note","name":"Note"},{"type":"heading","level":3,"anchor":"Example-implementation","text":"Example implementation"},{"type":"paragraph","inlineContent":[{"text":"Here’s a complete example of a simple print-based log handler:","type":"text"}]},{"type":"codeListing","code":["import Foundation","import Logging","","public struct PrintLogHandler: LogHandler {","    private let label: String","    public var logLevel: Logger.Level = .info","    public var metadata: Logger.Metadata = [:]","    ","    public init(label: String) {","        self.label = label","    }","    ","    public func log(","        level: Logger.Level,","        message: Logger.Message,","        metadata: Logger.Metadata?,","        source: String,","        file: String,","        function: String,","        line: UInt","    ) {","        let timestamp = ISO8601DateFormatter().string(from: Date())","        let levelString = level.rawValue.uppercased()","        ","        \/\/ Merge handler metadata with message metadata","        let combinedMetadata = Self.prepareMetadata(","            base: self.metadata","            explicit: metadata","        )","        ","        \/\/ Format metadata","        let metadataString = combinedMetadata.map { \"\\($0.key)=\\($0.value)\" }.joined(separator: \",\")","        ","        \/\/ Create log line and print to console","        let logLine = \"\\(label) \\(timestamp) \\(levelString) [\\(metadataString)]: \\(message)\"","        print(logLine)","    }","    ","    public subscript(metadataKey key: String) -> Logger.Metadata.Value? {","        get {","            return self.metadata[key]","        }","        set {","            self.metadata[key] = newValue","        }","    }","","    static func prepareMetadata(","        base: Logger.Metadata,","        explicit: Logger.Metadata?","    ) -> Logger.Metadata? {","        var metadata = base","","        guard let explicit else {","            \/\/ all per-log-statement values are empty","            return metadata","        }","","        metadata.merge(explicit, uniquingKeysWith: { _, explicit in explicit })","","        return metadata","    }","}",""],"syntax":"swift"},{"type":"heading","level":3,"anchor":"Advanced-features","text":"Advanced features"},{"type":"heading","level":4,"anchor":"Metadata-providers","text":"Metadata providers"},{"type":"paragraph","inlineContent":[{"text":"Metadata providers allow you to dynamically add contextual information to all","type":"text"},{"text":" ","type":"text"},{"text":"log messages without explicitly passing it each time. Common use cases include","type":"text"},{"text":" ","type":"text"},{"text":"request IDs, user sessions, or trace contexts that should be included in logs","type":"text"},{"text":" ","type":"text"},{"text":"throughout a request’s lifecycle.","type":"text"}]},{"code":["import Foundation","import Logging","","public struct PrintLogHandler: LogHandler {","    private let label: String","    public var logLevel: Logger.Level = .info","    public var metadata: Logger.Metadata = [:]","    public var metadataProvider: Logger.MetadataProvider?","    ","    public init(label: String) {","        self.label = label","    }","    ","    public func log(","        level: Logger.Level,","        message: Logger.Message,","        metadata: Logger.Metadata?,","        source: String,","        file: String,","        function: String,","        line: UInt","    ) {","        let timestamp = ISO8601DateFormatter().string(from: Date())","        let levelString = level.rawValue.uppercased()","        ","        \/\/ Get provider metadata","        let providerMetadata = metadataProvider?.get() ?? [:]","","        \/\/ Merge handler metadata with message metadata","        let combinedMetadata = Self.prepareMetadata(","            base: self.metadata,","            provider: self.metadataProvider,","            explicit: metadata","        )","        ","        \/\/ Format metadata","        let metadataString = combinedMetadata.map { \"\\($0.key)=\\($0.value)\" }.joined(separator: \",\")","        ","        \/\/ Create log line and print to console","        let logLine = \"\\(label) \\(timestamp) \\(levelString) [\\(metadataString)]: \\(message)\"","        print(logLine)","    }","    ","    public subscript(metadataKey key: String) -> Logger.Metadata.Value? {","        get {","            return self.metadata[key]","        }","        set {","            self.metadata[key] = newValue","        }","    }","","    static func prepareMetadata(","        base: Logger.Metadata,","        provider: Logger.MetadataProvider?,","        explicit: Logger.Metadata?","    ) -> Logger.Metadata? {","        var metadata = base","","        let provided = provider?.get() ?? [:]","","        guard !provided.isEmpty || !((explicit ?? [:]).isEmpty) else {","            \/\/ all per-log-statement values are empty","            return metadata","        }","","        if !provided.isEmpty {","            metadata.merge(provided, uniquingKeysWith: { _, provided in provided })","        }","","        if let explicit = explicit, !explicit.isEmpty {","            metadata.merge(explicit, uniquingKeysWith: { _, explicit in explicit })","        }","","        return metadata","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","level":3,"anchor":"Performance-considerations","text":"Performance considerations"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Avoid blocking"}],"type":"strong"},{"text":": Don’t block the calling thread for I\/O operations.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Lazy evaluation"}],"type":"strong"},{"type":"text","text":": Remember that messages and metadata are autoclosures."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Memory efficiency"}]},{"type":"text","text":": Don’t hold onto large amounts of messages."}],"type":"paragraph"}]}]}],"kind":"content"}],"references":{"doc://Logging/documentation/Logging/StreamLogHandler":{"role":"symbol","navigatorTitle":[{"text":"StreamLogHandler","kind":"identifier"}],"type":"topic","title":"StreamLogHandler","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"StreamLogHandler"}],"url":"\/documentation\/logging\/streamloghandler","kind":"symbol","identifier":"doc:\/\/Logging\/documentation\/Logging\/StreamLogHandler","abstract":[{"type":"text","text":"Stream log handler presents log messages to STDERR or STDOUT."}]},"doc://Logging/documentation/Logging":{"identifier":"doc:\/\/Logging\/documentation\/Logging","role":"collection","kind":"symbol","title":"Logging","url":"\/documentation\/logging","type":"topic","abstract":[{"type":"text","text":"A unified, performant, and ergonomic logging API for Swift."}]},"doc://Logging/documentation/Logging/MultiplexLogHandler":{"navigatorTitle":[{"kind":"identifier","text":"MultiplexLogHandler"}],"title":"MultiplexLogHandler","kind":"symbol","abstract":[{"text":"A pseudo log handler that sends messages to multiple other log handlers.","type":"text"}],"type":"topic","identifier":"doc:\/\/Logging\/documentation\/Logging\/MultiplexLogHandler","url":"\/documentation\/logging\/multiplexloghandler","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MultiplexLogHandler"}],"role":"symbol"},"doc://Logging/documentation/Logging/LogHandler":{"title":"LogHandler","type":"topic","kind":"symbol","url":"\/documentation\/logging\/loghandler","role":"symbol","navigatorTitle":[{"text":"LogHandler","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LogHandler","kind":"identifier"}],"identifier":"doc:\/\/Logging\/documentation\/Logging\/LogHandler","abstract":[{"type":"text","text":"A log handler provides an implementation of a logging backend."}]},"doc://Logging/documentation/Logging/LoggingBestPractices":{"url":"\/documentation\/logging\/loggingbestpractices","kind":"article","identifier":"doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices","type":"topic","title":"Logging best practices","abstract":[{"type":"text","text":"Best practices for effective logging with SwiftLog."}],"role":"collectionGroup"}}}