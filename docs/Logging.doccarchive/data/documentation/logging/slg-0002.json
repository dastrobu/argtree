{"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/logging\/slg-0002"]}],"sections":[],"metadata":{"roleHeading":"Article","modules":[{"name":"Logging"}],"role":"article","title":"SLG-0002: Compile-time log level elimination using traits"},"hierarchy":{"paths":[["doc:\/\/Logging\/documentation\/Logging"]]},"kind":"article","identifier":{"url":"doc:\/\/Logging\/documentation\/Logging\/SLG-0002","interfaceLanguage":"swift"},"abstract":[{"text":"Enable compile-time elimination of log levels to achieve zero runtime overhead for logs that will never be needed in production.","type":"text"}],"primaryContentSections":[{"content":[{"anchor":"Overview","type":"heading","level":2,"text":"Overview"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Proposal: SLG-0002","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Author(s): "},{"identifier":"https:\/\/github.com\/kukushechkin","isActive":true,"type":"reference"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Status: "},{"type":"strong","inlineContent":[{"text":"Ready for Implementation","type":"text"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Issue: "},{"identifier":"https:\/\/github.com\/apple\/swift-log\/issues\/378","type":"reference","isActive":true}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Implementation:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-log\/pull\/389"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Related links:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-log\/blob\/main\/Sources\/Logging\/Docs.docc\/Proposals\/Proposals.md","type":"reference"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"heading","level":3,"text":"Introduction","anchor":"Introduction"},{"inlineContent":[{"type":"text","text":"Add Swift package traits to allow applications to compile out less severe log levels, completely eliminating their runtime overhead from the final binary."}],"type":"paragraph"},{"type":"heading","level":3,"text":"Motivation","anchor":"Motivation"},{"inlineContent":[{"type":"text","text":"In production deployments, applications often know in advance which log levels will never be needed. For example, a production service typically only needs warning and above, while trace and debug levels are exclusively useful during development. Currently, even with the log level set to "},{"type":"codeVoice","code":".warning"},{"type":"text","text":" at runtime, the code for trace and debug statements still exists in the binary and incurs overhead."}],"type":"paragraph"},{"inlineContent":[{"text":"For performance-critical applications or resource-constrained environments, this overhead is unacceptable. Applications need a way to completely remove unnecessary log levels at compile time, achieving zero runtime cost.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Before this proposal, the only workarounds were:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Manually wrapping log statements in "},{"code":"#if DEBUG","type":"codeVoice"},{"type":"text","text":" checks (error-prone and verbose)"}]}]},{"content":[{"inlineContent":[{"text":"Accepting the runtime overhead (unacceptable for many use cases)","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Proposed-solution","text":"Proposed solution","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"This proposal introduces seven package traits that correspond to maximum log level thresholds. Applications specify a trait when declaring their dependency on SwiftLog, and all less severe log levels are completely compiled out."}]},{"type":"paragraph","inlineContent":[{"text":"In your ","type":"text"},{"type":"codeVoice","code":"Package.swift"},{"text":":","type":"text"}]},{"code":["dependencies: [","    .package(","        url: \"https:\/\/github.com\/apple\/swift-log.git\",","        from: \"1.0.0\",","        traits: [\"MaxLogLevelWarning\"]","    )","]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"With "},{"type":"codeVoice","code":"MaxLogLevelWarning"},{"type":"text","text":" enabled:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ These become no-ops (compiled out completely):","logger.trace(\"This will not be in the binary\")","logger.debug(\"This will not be in the binary\")","logger.info(\"This will not be in the binary\")","logger.notice(\"This will not be in the binary\")","logger.log(level: .debug, \"This will not log anything\")","","\/\/ These work normally:","logger.warning(\"This still works\")","logger.error(\"This still works\")","logger.critical(\"This still works\")","logger.log(level: .error, \"This still works\")"]},{"type":"heading","level":3,"text":"Detailed design","anchor":"Detailed-design"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The seven available traits, ordered from most permissive to most restrictive, are:"}]},{"syntax":"swift","type":"codeListing","code":["traits: [","    .trait(name: \"MaxLogLevelDebug\", description: \"Debug and above available (compiles out trace)\"),","    .trait(name: \"MaxLogLevelInfo\", description: \"Info and above available (compiles out trace, debug)\"),","    .trait(name: \"MaxLogLevelNotice\", description: \"Notice and above available (compiles out trace, debug, info)\"),","    .trait(","        name: \"MaxLogLevelWarning\",","        description: \"Warning and above available (compiles out trace, debug, info, notice)\"","    ),","    .trait(","        name: \"MaxLogLevelError\",","        description: \"Error and above available (compiles out trace, debug, info, notice, warning)\"","    ),","    .trait(name: \"MaxLogLevelCritical\", description: \"Only critical available (compiles out all except critical)\"),","    .trait(name: \"MaxLogLevelNone\", description: \"All logging compiled out (no log levels available)\"),","","    .default(enabledTraits: []),","]"]},{"inlineContent":[{"text":"By default (when no traits are specified), all log levels remain available.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Traits are additive: if multiple max level traits are specified in the dependency graph, the most restrictive one takes effect. This ensures that if any dependency requests stricter elimination, the entire build respects it."}],"type":"paragraph"},{"name":"Important","type":"aside","style":"important","content":[{"type":"paragraph","inlineContent":[{"text":"Traits should only be set by applications, not libraries, as any trait defined in a transitive dependency will affect the entire dependency resolution tree.","type":"text"}]}]},{"inlineContent":[{"type":"text","text":"For the generic "},{"type":"codeVoice","code":"log(level:)"},{"type":"text","text":" method, the implementation switches behavior based on whether any trait is enabled:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["public func log(","    level: Logger.Level,","    _ message: @autoclosure () -> Logger.Message,","    metadata: @autoclosure () -> Logger.Metadata? = nil,","    source: @autoclosure () -> String? = nil,","    file: String = #fileID,","    function: String = #function,","    line: UInt = #line",") {","    #if MaxLogLevelDebug || MaxLogLevelInfo || MaxLogLevelNotice || MaxLogLevelWarning || MaxLogLevelError || MaxLogLevelCritical || MaxLogLevelNone","    \/\/ When traits are enabled, dispatch to level-specific methods","    \/\/ to leverage their compile-time elimination","    switch level {","    case .trace:","        self.trace(message(), metadata: metadata(), source: source(), file: file, function: function, line: line)","    case .debug:","        self.debug(message(), metadata: metadata(), source: source(), file: file, function: function, line: line)","    \/\/ ... (all levels)","    }","    #else","    \/\/ When no traits are enabled, avoid the switch overhead","    self._log(","        level: level,","        message(),","        metadata: metadata(),","        source: source(),","        file: file,","        function: function,","        line: line","    )","    #endif","}"]},{"inlineContent":[{"text":"This approach adds a minimal switch statement overhead when traits are enabled, but allows the level-specific methodsâ€™ compile-time elimination to work even when called through ","type":"text"},{"type":"codeVoice","code":"log(level:)"},{"text":". When no traits are enabled, the original zero-overhead path is preserved. Level-specific methods has no additional overhead.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"API-stability","text":"API stability"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"For existing "},{"code":"Logger","type":"codeVoice"},{"type":"text","text":" users:"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When no traits are enabled (the default), behavior is identical to before"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Users can opt in to traits at the application level without modifying any source code"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"For existing "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" implementations:"}]}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"No changes are required to any "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" implementation"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"type":"heading","text":"Future directions","anchor":"Future-directions"},{"inlineContent":[{"text":"No future directions identified.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","text":"Alternatives considered","anchor":"Alternatives-considered"},{"level":4,"type":"heading","text":"Per-log-level traits","anchor":"Per-log-level-traits"},{"inlineContent":[{"text":"An alternative approach would be to define one trait per log level that could be individually disabled:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["traits: [","    .trait(name: \"DisableTraceLogs\"),","    .trait(name: \"DisableDebugLogs\"),","    .trait(name: \"DisableInfoLogs\"),","    .trait(name: \"DisableNoticeLogs\"),","    .trait(name: \"DisableWarningLogs\"),","    .trait(name: \"DisableErrorLogs\"),","    .trait(name: \"DisableCriticalLogs\"),","]"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Users would specify multiple traits to eliminate multiple levels:"}]},{"type":"codeListing","code":[".package(","    url: \"https:\/\/github.com\/apple\/swift-log.git\",","    from: \"1.0.0\",","    traits: [\"DisableTraceLogs\", \"DisableDebugLogs\", \"DisableInfoLogs\", \"DisableNoticeLogs\"]",")"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"This approach was rejected in favor of a "},{"type":"codeVoice","code":"MaxLogLevel"},{"text":" semantics to make it less verbose to use the functionality and to be aligned with the similar functionality in logging packages in other languages users might already be familiar with.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"references":{"doc://Logging/documentation/Logging":{"role":"collection","kind":"symbol","title":"Logging","abstract":[{"type":"text","text":"A unified, performant, and ergonomic logging API for Swift."}],"identifier":"doc:\/\/Logging\/documentation\/Logging","url":"\/documentation\/logging","type":"topic"},"https://github.com/apple/swift-log/blob/main/Sources/Logging/Docs.docc/Proposals/Proposals.md":{"url":"https:\/\/github.com\/apple\/swift-log\/blob\/main\/Sources\/Logging\/Docs.docc\/Proposals\/Proposals.md","type":"link","title":"Lightweight proposals process description","titleInlineContent":[{"text":"Lightweight proposals process description","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-log\/blob\/main\/Sources\/Logging\/Docs.docc\/Proposals\/Proposals.md"},"https://github.com/kukushechkin":{"url":"https:\/\/github.com\/kukushechkin","title":"Vladimir Kukushkin","identifier":"https:\/\/github.com\/kukushechkin","titleInlineContent":[{"type":"text","text":"Vladimir Kukushkin"}],"type":"link"},"https://github.com/apple/swift-log/pull/389":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-log\/pull\/389","title":"apple\/swift-log#389","titleInlineContent":[{"type":"text","text":"apple\/swift-log#389"}],"url":"https:\/\/github.com\/apple\/swift-log\/pull\/389"},"https://github.com/apple/swift-log/issues/378":{"url":"https:\/\/github.com\/apple\/swift-log\/issues\/378","type":"link","title":"apple\/swift-log#378","titleInlineContent":[{"text":"apple\/swift-log#378","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-log\/issues\/378"}}}