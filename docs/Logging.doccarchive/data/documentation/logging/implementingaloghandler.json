{"metadata":{"modules":[{"name":"Logging"}],"role":"article","title":"Implementing a log handler","roleHeading":"Article"},"identifier":{"url":"doc:\/\/Logging\/documentation\/Logging\/ImplementingALogHandler","interfaceLanguage":"swift"},"kind":"article","schemaVersion":{"patch":0,"major":0,"minor":3},"seeAlsoSections":[{"identifiers":["doc:\/\/Logging\/documentation\/Logging\/LogHandler","doc:\/\/Logging\/documentation\/Logging\/StreamLogHandler","doc:\/\/Logging\/documentation\/Logging\/MultiplexLogHandler"],"title":"Related Documentation","anchor":"Related-Documentation"},{"identifiers":["doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices"],"anchor":"Best-Practices","title":"Best Practices","generated":true}],"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/logging\/implementingaloghandler"]}],"abstract":[{"type":"text","text":"Create a custom logging backend that provides logging services for your apps and libraries."}],"hierarchy":{"paths":[["doc:\/\/Logging\/documentation\/Logging"]]},"primaryContentSections":[{"content":[{"level":2,"type":"heading","anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"To become a compatible logging backend that any SwiftLog consumer can use,","type":"text"},{"text":" ","type":"text"},{"text":"you need to fulfill a few requirements, primarily conforming to the","type":"text"},{"text":" ","type":"text"},{"identifier":"doc:\/\/Logging\/documentation\/Logging\/LogHandler","type":"reference","isActive":true},{"text":" protocol.","type":"text"}]},{"type":"heading","text":"Implement with value type semantics","level":3,"anchor":"Implement-with-value-type-semantics"},{"type":"paragraph","inlineContent":[{"text":"Your log handler ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"must be a "},{"type":"codeVoice","code":"struct"}]},{"text":" and exhibit value semantics. This","type":"text"},{"text":" ","type":"text"},{"text":"ensures that changes to one logger don’t affect others.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"To verify that your handler reflects value semantics ensure that it passes this","type":"text"},{"text":" ","type":"text"},{"text":"test:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@Test","func logHandlerValueSemantics() {","    LoggingSystem.bootstrap(MyLogHandler.init)","    var logger1 = Logger(label: \"first logger\")","    logger1.logLevel = .debug","    logger1[metadataKey: \"only-on\"] = \"first\"","    ","    var logger2 = logger1","    logger2.logLevel = .error                  \/\/ Must not affect logger1","    logger2[metadataKey: \"only-on\"] = \"second\" \/\/ Must not affect logger1","    ","    \/\/ These expectations must pass","    #expect(logger1.logLevel == .debug)","    #expect(logger2.logLevel == .error)","    #expect(logger1[metadataKey: \"only-on\"] == \"first\")","    #expect(logger2[metadataKey: \"only-on\"] == \"second\")","}"]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"In special cases, it is acceptable for a log handler to provide","type":"text"},{"text":" ","type":"text"},{"text":"global log level overrides that may affect all log handlers created.","type":"text"}]}],"name":"Note","style":"note"},{"type":"heading","text":"Example implementation","level":3,"anchor":"Example-implementation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a complete example of a simple print-based log handler:"}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Logging","","public struct PrintLogHandler: LogHandler {","    private let label: String","    public var logLevel: Logger.Level = .info","    public var metadata: Logger.Metadata = [:]","    ","    public init(label: String) {","        self.label = label","    }","    ","    public func log(","        level: Logger.Level,","        message: Logger.Message,","        metadata: Logger.Metadata?,","        source: String,","        file: String,","        function: String,","        line: UInt","    ) {","        let timestamp = ISO8601DateFormatter().string(from: Date())","        let levelString = level.rawValue.uppercased()","        ","        \/\/ Merge handler metadata with message metadata","        let combinedMetadata = Self.prepareMetadata(","            base: self.metadata","            explicit: metadata","        )","        ","        \/\/ Format metadata","        let metadataString = combinedMetadata.map { \"\\($0.key)=\\($0.value)\" }.joined(separator: \",\")","        ","        \/\/ Create log line and print to console","        let logLine = \"\\(label) \\(timestamp) \\(levelString) [\\(metadataString)]: \\(message)\"","        print(logLine)","    }","    ","    public subscript(metadataKey key: String) -> Logger.Metadata.Value? {","        get {","            return self.metadata[key]","        }","        set {","            self.metadata[key] = newValue","        }","    }","","    static func prepareMetadata(","        base: Logger.Metadata,","        explicit: Logger.Metadata?","    ) -> Logger.Metadata? {","        var metadata = base","","        guard let explicit else {","            \/\/ all per-log-statement values are empty","            return metadata","        }","","        metadata.merge(explicit, uniquingKeysWith: { _, explicit in explicit })","","        return metadata","    }","}",""]},{"type":"heading","text":"Advanced features","level":3,"anchor":"Advanced-features"},{"type":"heading","text":"Metadata providers","level":4,"anchor":"Metadata-providers"},{"type":"paragraph","inlineContent":[{"text":"Metadata providers allow you to dynamically add contextual information to all","type":"text"},{"text":" ","type":"text"},{"text":"log messages without explicitly passing it each time. Common use cases include","type":"text"},{"text":" ","type":"text"},{"text":"request IDs, user sessions, or trace contexts that should be included in logs","type":"text"},{"text":" ","type":"text"},{"text":"throughout a request’s lifecycle.","type":"text"}]},{"code":["import Foundation","import Logging","","public struct PrintLogHandler: LogHandler {","    private let label: String","    public var logLevel: Logger.Level = .info","    public var metadata: Logger.Metadata = [:]","    public var metadataProvider: Logger.MetadataProvider?","    ","    public init(label: String) {","        self.label = label","    }","    ","    public func log(","        level: Logger.Level,","        message: Logger.Message,","        metadata: Logger.Metadata?,","        source: String,","        file: String,","        function: String,","        line: UInt","    ) {","        let timestamp = ISO8601DateFormatter().string(from: Date())","        let levelString = level.rawValue.uppercased()","        ","        \/\/ Get provider metadata","        let providerMetadata = metadataProvider?.get() ?? [:]","","        \/\/ Merge handler metadata with message metadata","        let combinedMetadata = Self.prepareMetadata(","            base: self.metadata,","            provider: self.metadataProvider,","            explicit: metadata","        )","        ","        \/\/ Format metadata","        let metadataString = combinedMetadata.map { \"\\($0.key)=\\($0.value)\" }.joined(separator: \",\")","        ","        \/\/ Create log line and print to console","        let logLine = \"\\(label) \\(timestamp) \\(levelString) [\\(metadataString)]: \\(message)\"","        print(logLine)","    }","    ","    public subscript(metadataKey key: String) -> Logger.Metadata.Value? {","        get {","            return self.metadata[key]","        }","        set {","            self.metadata[key] = newValue","        }","    }","","    static func prepareMetadata(","        base: Logger.Metadata,","        provider: Logger.MetadataProvider?,","        explicit: Logger.Metadata?","    ) -> Logger.Metadata? {","        var metadata = base","","        let provided = provider?.get() ?? [:]","","        guard !provided.isEmpty || !((explicit ?? [:]).isEmpty) else {","            \/\/ all per-log-statement values are empty","            return metadata","        }","","        if !provided.isEmpty {","            metadata.merge(provided, uniquingKeysWith: { _, provided in provided })","        }","","        if let explicit = explicit, !explicit.isEmpty {","            metadata.merge(explicit, uniquingKeysWith: { _, explicit in explicit })","        }","","        return metadata","    }","}"],"syntax":"swift","type":"codeListing"},{"level":3,"text":"Performance considerations","anchor":"Performance-considerations","type":"heading"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Avoid blocking"}],"type":"strong"},{"type":"text","text":": Don’t block the calling thread for I\/O operations."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Lazy evaluation"}],"type":"strong"},{"text":": Remember that messages and metadata are autoclosures.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Memory efficiency"}],"type":"strong"},{"type":"text","text":": Don’t hold onto large amounts of messages."}],"type":"paragraph"}]}],"type":"orderedList"}],"kind":"content"}],"references":{"doc://Logging/documentation/Logging/LoggingBestPractices":{"kind":"article","url":"\/documentation\/logging\/loggingbestpractices","role":"collectionGroup","type":"topic","title":"Logging best practices","identifier":"doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices","abstract":[{"type":"text","text":"Best practices for effective logging with SwiftLog."}]},"doc://Logging/documentation/Logging/LogHandler":{"role":"symbol","type":"topic","kind":"symbol","title":"LogHandler","abstract":[{"text":"A log handler provides an implementation of a logging backend.","type":"text"}],"navigatorTitle":[{"text":"LogHandler","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LogHandler","kind":"identifier"}],"identifier":"doc:\/\/Logging\/documentation\/Logging\/LogHandler","url":"\/documentation\/logging\/loghandler"},"doc://Logging/documentation/Logging":{"role":"collection","kind":"symbol","title":"Logging","abstract":[{"type":"text","text":"A unified, performant, and ergonomic logging API for Swift."}],"identifier":"doc:\/\/Logging\/documentation\/Logging","url":"\/documentation\/logging","type":"topic"},"doc://Logging/documentation/Logging/MultiplexLogHandler":{"identifier":"doc:\/\/Logging\/documentation\/Logging\/MultiplexLogHandler","abstract":[{"type":"text","text":"A pseudo log handler that sends messages to multiple other log handlers."}],"type":"topic","url":"\/documentation\/logging\/multiplexloghandler","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"MultiplexLogHandler"}],"title":"MultiplexLogHandler","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"MultiplexLogHandler"}]},"doc://Logging/documentation/Logging/StreamLogHandler":{"identifier":"doc:\/\/Logging\/documentation\/Logging\/StreamLogHandler","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"StreamLogHandler"}],"title":"StreamLogHandler","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"StreamLogHandler"}],"kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Stream log handler presents log messages to STDERR or STDOUT."}],"url":"\/documentation\/logging\/streamloghandler"}}}