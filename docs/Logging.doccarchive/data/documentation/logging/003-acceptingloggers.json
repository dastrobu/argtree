{"schemaVersion":{"minor":3,"major":0,"patch":0},"sections":[],"kind":"article","seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/Logging\/documentation\/Logging\/001-ChoosingLogLevels","doc:\/\/Logging\/documentation\/Logging\/002-StructuredLogging"]}],"metadata":{"modules":[{"name":"Logging"}],"roleHeading":"Article","role":"article","title":"003: Accepting loggers in libraries"},"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Libraries should accept logger instances through method parameters rather than"},{"type":"text","text":" "},{"type":"text","text":"storing them as instance variables. This practice ensures metadata (such as"},{"type":"text","text":" "},{"type":"text","text":"correlation IDs) is properly propagated down the call stack, while giving"},{"type":"text","text":" "},{"type":"text","text":"applications control over logging configuration."}]},{"anchor":"Motivation","text":"Motivation","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"When libraries accept loggers as method parameters, they enable automatic"},{"type":"text","text":" "},{"type":"text","text":"propagation of contextual metadata attached to the logger instance. This is"},{"type":"text","text":" "},{"type":"text","text":"especially important for distributed systems where correlation IDs must flow"},{"type":"text","text":" "},{"type":"text","text":"through the entire request processing pipeline."}]},{"anchor":"Example","text":"Example","type":"heading","level":3},{"anchor":"Recommended-Accept-logger-through-method-parameters","text":"Recommended: Accept logger through method parameters","type":"heading","level":4},{"syntax":"swift","type":"codeListing","code":["\/\/ ✅ Good: Pass the logger through method parameters.","struct RequestProcessor {","    func processRequest(_ request: HTTPRequest, logger: Logger) async throws -> HTTPResponse {","        \/\/ Add structured metadata that every log statement should contain.","        var logger = logger","        logger[metadataKey: \"request.method\"] = \"\\(request.method)\"","        logger[metadataKey: \"request.path\"] = \"\\(request.path)\"","        logger[metadataKey: \"request.id\"] = \"\\(request.id)\"","","        logger.debug(\"Processing request\")","        ","        \/\/ Pass the logger down to maintain metadata context.","        let validatedData = try validateRequest(request, logger: logger)","        let result = try await executeBusinessLogic(validatedData, logger: logger)","        ","        logger.debug(\"Request processed successfully\")","        return result","    }","    ","    private func validateRequest(_ request: HTTPRequest, logger: Logger) throws -> ValidatedRequest {","        logger.debug(\"Validating request parameters\")","        \/\/ Include validation logic that uses the same logger context.","        return ValidatedRequest(request)","    }","    ","    private func executeBusinessLogic(_ data: ValidatedRequest, logger: Logger) async throws -> HTTPResponse {","        logger.debug(\"Executing business logic\")","        ","        \/\/ Further propagate the logger to other services.","        let dbResult = try await databaseService.query(data.query, logger: logger)","        ","        logger.debug(\"Business logic completed\")","        return HTTPResponse(data: dbResult)","    }","}"]},{"anchor":"Alternative-Accept-logger-through-initializer-when-appropriate","text":"Alternative: Accept logger through initializer when appropriate","type":"heading","level":4},{"syntax":"swift","type":"codeListing","code":["\/\/ ✅ Acceptable: Logger through initializer for long-lived components","final class BackgroundJobProcessor {","    private let logger: Logger","    ","    init(logger: Logger) {","        self.logger = logger","    }","    ","    func run() async {","        \/\/ Execute some long running work","        logger.debug(\"Update about long running work\")","        \/\/ Execute some more long running work","    }","}"]},{"anchor":"Avoid-Libraries-creating-their-own-loggers","text":"Avoid: Libraries creating their own loggers","type":"heading","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"Libraries might create their own loggers; however, this leads to two problems."},{"type":"text","text":" "},{"type":"text","text":"First, users of the library can’t inject their own loggers which means they have"},{"type":"text","text":" "},{"type":"text","text":"no control in customizing the log level or log handler. Secondly, it breaks the"},{"type":"text","text":" "},{"type":"text","text":"metadata propagation since users can’t pass in a logger with already attached"},{"type":"text","text":" "},{"type":"text","text":"metadata."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ ❌ Bad: Library creates its own logger","final class MyLibrary {","    private let logger = Logger(label: \"MyLibrary\")  \/\/ Loses all context","}","","\/\/ ✅ Good: Library accepts logger from caller","final class MyLibrary {","    func operation(logger: Logger) {","        \/\/ Maintains caller's context and metadata","    }","}"]}],"kind":"content"}],"abstract":[{"text":"Accept loggers through method parameters to ensure proper metadata propagation.","type":"text"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/logging\/003-acceptingloggers"]}],"hierarchy":{"paths":[["doc:\/\/Logging\/documentation\/Logging","doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices"]]},"identifier":{"url":"doc:\/\/Logging\/documentation\/Logging\/003-AcceptingLoggers","interfaceLanguage":"swift"},"references":{"doc://Logging/documentation/Logging/002-StructuredLogging":{"abstract":[{"text":"Use metadata to create machine-readable, searchable log entries.","type":"text"}],"kind":"article","type":"topic","role":"article","url":"\/documentation\/logging\/002-structuredlogging","title":"002: Structured logging","identifier":"doc:\/\/Logging\/documentation\/Logging\/002-StructuredLogging"},"doc://Logging/documentation/Logging":{"role":"collection","kind":"symbol","title":"Logging","abstract":[{"type":"text","text":"A unified, performant, and ergonomic logging API for Swift."}],"identifier":"doc:\/\/Logging\/documentation\/Logging","url":"\/documentation\/logging","type":"topic"},"doc://Logging/documentation/Logging/LoggingBestPractices":{"kind":"article","url":"\/documentation\/logging\/loggingbestpractices","role":"collectionGroup","type":"topic","title":"Logging best practices","identifier":"doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices","abstract":[{"type":"text","text":"Best practices for effective logging with SwiftLog."}]},"doc://Logging/documentation/Logging/001-ChoosingLogLevels":{"role":"article","title":"001: Choosing log levels","kind":"article","abstract":[{"text":"Select appropriate log levels in applications and libraries.","type":"text"}],"url":"\/documentation\/logging\/001-choosingloglevels","type":"topic","identifier":"doc:\/\/Logging\/documentation\/Logging\/001-ChoosingLogLevels"}}}