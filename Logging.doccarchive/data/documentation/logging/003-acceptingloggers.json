{"kind":"article","hierarchy":{"paths":[["doc:\/\/Logging\/documentation\/Logging","doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices"]]},"metadata":{"title":"003: Accepting loggers in libraries","role":"article","roleHeading":"Article","modules":[{"name":"Logging"}]},"primaryContentSections":[{"content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"Libraries should accept logger instances through method parameters rather than"},{"type":"text","text":" "},{"type":"text","text":"storing them as instance variables. This practice ensures metadata (such as"},{"type":"text","text":" "},{"type":"text","text":"correlation IDs) is properly propagated down the call stack, while giving"},{"type":"text","text":" "},{"type":"text","text":"applications control over logging configuration."}],"type":"paragraph"},{"anchor":"Motivation","level":3,"type":"heading","text":"Motivation"},{"inlineContent":[{"type":"text","text":"When libraries accept loggers as method parameters, they enable automatic"},{"type":"text","text":" "},{"type":"text","text":"propagation of contextual metadata attached to the logger instance. This is"},{"type":"text","text":" "},{"type":"text","text":"especially important for distributed systems where correlation IDs must flow"},{"type":"text","text":" "},{"type":"text","text":"through the entire request processing pipeline."}],"type":"paragraph"},{"anchor":"Example","level":3,"type":"heading","text":"Example"},{"anchor":"Recommended-Accept-logger-through-method-parameters","level":4,"type":"heading","text":"Recommended: Accept logger through method parameters"},{"syntax":"swift","code":["\/\/ ✅ Good: Pass the logger through method parameters.","struct RequestProcessor {","    func processRequest(_ request: HTTPRequest, logger: Logger) async throws -> HTTPResponse {","        \/\/ Add structured metadata that every log statement should contain.","        var logger = logger","        logger[metadataKey: \"request.method\"] = \"\\(request.method)\"","        logger[metadataKey: \"request.path\"] = \"\\(request.path)\"","        logger[metadataKey: \"request.id\"] = \"\\(request.id)\"","","        logger.debug(\"Processing request\")","        ","        \/\/ Pass the logger down to maintain metadata context.","        let validatedData = try validateRequest(request, logger: logger)","        let result = try await executeBusinessLogic(validatedData, logger: logger)","        ","        logger.debug(\"Request processed successfully\")","        return result","    }","    ","    private func validateRequest(_ request: HTTPRequest, logger: Logger) throws -> ValidatedRequest {","        logger.debug(\"Validating request parameters\")","        \/\/ Include validation logic that uses the same logger context.","        return ValidatedRequest(request)","    }","    ","    private func executeBusinessLogic(_ data: ValidatedRequest, logger: Logger) async throws -> HTTPResponse {","        logger.debug(\"Executing business logic\")","        ","        \/\/ Further propagate the logger to other services.","        let dbResult = try await databaseService.query(data.query, logger: logger)","        ","        logger.debug(\"Business logic completed\")","        return HTTPResponse(data: dbResult)","    }","}"],"type":"codeListing"},{"anchor":"Alternative-Accept-logger-through-initializer-when-appropriate","level":4,"type":"heading","text":"Alternative: Accept logger through initializer when appropriate"},{"syntax":"swift","code":["\/\/ ✅ Acceptable: Logger through initializer for long-lived components","final class BackgroundJobProcessor {","    private let logger: Logger","    ","    init(logger: Logger) {","        self.logger = logger","    }","    ","    func run() async {","        \/\/ Execute some long running work","        logger.debug(\"Update about long running work\")","        \/\/ Execute some more long running work","    }","}"],"type":"codeListing"},{"anchor":"Avoid-Libraries-creating-their-own-loggers","level":4,"type":"heading","text":"Avoid: Libraries creating their own loggers"},{"inlineContent":[{"type":"text","text":"Libraries might create their own loggers; however, this leads to two problems."},{"type":"text","text":" "},{"type":"text","text":"First, users of the library can’t inject their own loggers which means they have"},{"type":"text","text":" "},{"type":"text","text":"no control in customizing the log level or log handler. Secondly, it breaks the"},{"type":"text","text":" "},{"type":"text","text":"metadata propagation since users can’t pass in a logger with already attached"},{"type":"text","text":" "},{"type":"text","text":"metadata."}],"type":"paragraph"},{"code":["\/\/ ❌ Bad: Library creates its own logger","final class MyLibrary {","    private let logger = Logger(label: \"MyLibrary\")  \/\/ Loses all context","}","","\/\/ ✅ Good: Library accepts logger from caller","final class MyLibrary {","    func operation(logger: Logger) {","        \/\/ Maintains caller's context and metadata","    }","}"],"syntax":"swift","type":"codeListing"}],"kind":"content"}],"identifier":{"url":"doc:\/\/Logging\/documentation\/Logging\/003-AcceptingLoggers","interfaceLanguage":"swift"},"variants":[{"paths":["\/documentation\/logging\/003-acceptingloggers"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"text":"Accept loggers through method parameters to ensure proper metadata propagation.","type":"text"}],"seeAlsoSections":[{"identifiers":["doc:\/\/Logging\/documentation\/Logging\/001-ChoosingLogLevels","doc:\/\/Logging\/documentation\/Logging\/002-StructuredLogging"],"generated":true}],"sections":[],"schemaVersion":{"minor":3,"major":0,"patch":0},"references":{"doc://Logging/documentation/Logging/002-StructuredLogging":{"abstract":[{"type":"text","text":"Use metadata to create machine-readable, searchable log entries."}],"identifier":"doc:\/\/Logging\/documentation\/Logging\/002-StructuredLogging","title":"002: Structured logging","type":"topic","kind":"article","role":"article","url":"\/documentation\/logging\/002-structuredlogging"},"doc://Logging/documentation/Logging":{"identifier":"doc:\/\/Logging\/documentation\/Logging","role":"collection","kind":"symbol","title":"Logging","url":"\/documentation\/logging","type":"topic","abstract":[{"type":"text","text":"A unified, performant, and ergonomic logging API for Swift."}]},"doc://Logging/documentation/Logging/001-ChoosingLogLevels":{"title":"001: Choosing log levels","url":"\/documentation\/logging\/001-choosingloglevels","type":"topic","role":"article","kind":"article","identifier":"doc:\/\/Logging\/documentation\/Logging\/001-ChoosingLogLevels","abstract":[{"text":"Select appropriate log levels in applications and libraries.","type":"text"}]},"doc://Logging/documentation/Logging/LoggingBestPractices":{"url":"\/documentation\/logging\/loggingbestpractices","kind":"article","identifier":"doc:\/\/Logging\/documentation\/Logging\/LoggingBestPractices","type":"topic","title":"Logging best practices","abstract":[{"type":"text","text":"Best practices for effective logging with SwiftLog."}],"role":"collectionGroup"}}}