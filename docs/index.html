<!DOCTYPE html>
<html lang="en">
  <head>
    <title>  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html"> Docs</a> (100% documented)</p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html"> Reference</a>
        <img id="carat" src="img/carat.png" />
          Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/LoggingSystem.html">LoggingSystem</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/LogHandler.html">LogHandler</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/Logger.html">Logger</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Logger/MetadataValue.html">– MetadataValue</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Logger/Level.html">– Level</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Logger/Message.html">– Message</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/MultiplexLogHandler.html">MultiplexLogHandler</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/StreamLogHandler.html">StreamLogHandler</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 id='argtree' class='heading'>argtree</h1>

<p><a href="https://swift.org"><img src="https://img.shields.io/badge/swift-5.1-blue.svg" alt="Swift Version"></a> 
<img src="https://img.shields.io/badge/platform-osx--64%7Clinux--64-lightgrey.svg" alt="Platform">
<a href="https://travis-ci.org/dastrobu/argtree"><img src="https://travis-ci.org/dastrobu/argtree.svg?branch=master" alt="Build Travis-CI Status"></a> </p>

<p>Command line argument parser package in Swift.</p>

<p>The basic idea is to define a tree structure of parsers which then parses all command line arguments.
This approach is very flexible and allows for quick and easy flag parsing for a simple scirpt, as well as 
complicated parse trees for big command command line programs.</p>
<h2 id='table-of-contents' class='heading'>Table of Contents</h2>

<ul>
<li><a href="#installation">Installation</a>

<ul>
<li><a href="#swift-package-manager">Swift Package Manager</a></li>
<li><a href="#dependencies">Dependencies</a></li>
</ul></li>
<li><a href="#getting-started">Getting started</a>

<ul>
<li><a href="#help-text-generation">Help Text generation</a></li>
</ul></li>
<li><a href="#parsers">Parsers</a>

<ul>
<li><a href="#flag">Flag</a></li>
<li><a href="#option">Option</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#var-args">Var Args</a></li>
<li><a href="#handling-unexpected-arguments">Handling Unexpected Arguments</a></li>
</ul></li>
<li><a href="#default-action-1">Default Action</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#architecture">Architecture</a>

<ul>
<li><a href="#parse-path">Parse Path</a></li>
</ul></li>
</ul>
<h2 id='installation' class='heading'>Installation</h2>
<h3 id='swift-package-manager' class='heading'>Swift Package Manager</h3>
<pre class="highlight plaintext"><code>dependencies: [
        .package(url: "https://github.com/dastrobu/argtree.git", from: "1.0.0"),
    ],
</code></pre>
<h3 id='dependencies' class='heading'>Dependencies</h3>

<p>At least <code>clang-3.6</code> is required. On linux one might need to install it explicitly.
There are no dependencies on macOS.</p>
<h2 id='getting-started' class='heading'>Getting started</h2>

<p>The following example shows a hello world script with one flag (no option or command) and generated help.</p>
<pre class="highlight swift"><code><span class="c1">// global modal for the application</span>
<span class="k">var</span> <span class="nv">verbose</span> <span class="o">=</span> <span class="kc">false</span>

<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span>
<span class="s">"""
usage: </span><span class="se">\(</span><span class="kt">CommandLine</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="se">)</span><span class="s">) [flags...]

hello world demo

flags:
"""</span><span class="p">,</span>
    <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
        <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"verbose"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"v"</span><span class="p">,</span> <span class="nv">description</span><span class="p">:</span> <span class="s">"print verbose output"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>

<span class="c1">// here comes the real program code after parsing the command line arguments</span>
<span class="k">if</span> <span class="n">verbose</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hi"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<h3 id='help-text-generation' class='heading'>Help Text generation</h3>

<p>Help texts can be generated automatically (partially), detailed in <a href="#automatic-help-flag">Automatic Help Flag</a>.
This is only true for global help. 
Help on individual commands is not generated, can however, easily be implemented by adding a <code>Help</code> flag to the command.</p>
<h2 id='parsers' class='heading'>Parsers</h2>

<p>There are a variaty of parsers implemented to compose the parser tree. </p>

<ul>
<li><a href="#flag">Flag</a></li>
<li><a href="#option">Option</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#varargs">VarArgs</a></li>
</ul>

<p>If those are not sufficient, it is easy to implement a custom parser. Therefore, the <code>Parser</code> interface must be 
implemented, see <a href="#architecture">Architecture</a> for details.</p>
<h3 id='flag' class='heading'>Flag</h3>

<p>A flag is a boolean property like <code>-v</code> or <code>--verbose</code>. A flag has a long and a short name, both are optional 
(however, not setting any of them does not make sense).
Handling a flag can either be done via the <code>parsed</code> closure</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">verbose</span> <span class="o">=</span> <span class="kc">false</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"verbose"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"v"</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="n">path</span> <span class="k">in</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>or by accessing the parsed values later.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">verboseFlag</span> <span class="o">=</span> <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"verbose"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"v"</span><span class="p">)</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">verboseFlag</span><span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">verbose</span> <span class="o">=</span> <span class="n">verboseFlag</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">nil</span>
</code></pre>
<h4 id='flag-prefixes' class='heading'>Flag Prefixes</h4>

<p>By default long names get the prefix <q>&ndash;</q> and short names get the prefix <q>-</q>. 
Other prefixes, to handle e.g. <code>+a</code>, can be specified.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="kt">Flag</span><span class="p">(</span><span class="nv">shortName</span><span class="p">:</span> <span class="s">"a"</span><span class="p">,</span> <span class="nv">shortPrefix</span><span class="p">:</span> <span class="s">"+"</span><span class="p">)</span>
</code></pre>

<p>The same can be done for long prefixes.</p>
<h4 id='passing-a-flag-multiple-times' class='heading'>Passing a Flag Multiple Times</h4>

<p>By default passing the same flag multiple times is reported as error (<code>FlagParseError.flagAllowedOnlyOnce</code>). 
Sometimes it is, however, useful to be able to pass the same flag multiple times, e.g. if <code>-v</code> should print
a verbose output and <code>-v -v</code> should print a very verbose output. In this case the flag should have set the 
property <code>multiAllowed</code> to true. </p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">verboseFlag</span> <span class="o">=</span> <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"verbose"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"v"</span><span class="p">,</span> <span class="nv">multiAllowed</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">verboseFlag</span><span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">verbosity</span> <span class="o">=</span> <span class="n">verboseFlag</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">count</span>
</code></pre>

<p>The number of times the value was parsed can be accassed via the <code>values</code> property. It is up to the implementation
to decide if passing the same flag multiple times is simply ignored or meaning something useful.</p>
<h4 id='handling-unexpected-flags' class='heading'>Handling Unexpected Flags</h4>

<p>By default, nothing happens if a flag was set at the command line, that has no meaning, i.e. that is not parsed.
To report all flag like arguments that have not meaning as errors, simply add the <code>UnexpectedFlagHandler</code> to 
the parsers. The handler must be added after the flag parsers, to report errors correctly.</p>
<pre class="highlight swift"><code><span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
        <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"verbose"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"v"</span><span class="p">)</span>
        <span class="kt">UnexpectedFlagHandler</span><span class="p">()</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>In this case, all arguments starting with either the long or short prefix will be reported as errors. 
The <code>UnexpectedFlagHandler</code> supports a <a href="#stop-token">Stop Token</a>, to allow for flag like var args. Also, 
the <code>longPrefix</code> and <code>shortPrefix</code> can be customized. 
If flags with different prefixes are used, e.g. <code>-a</code> and <code>+a</code>, two seperate <code>UnexpectedFlagHandler</code> can be added, 
one for the standard prefix and one for the <code>+</code> prefix.</p>
<h4 id='multi-flags' class='heading'>Multi Flags</h4>

<p>Multi flags are combined flags (for short names). For example if there are flags <code>-a</code> and <code>-b</code> one could also 
pass the combined flag <code>-ab</code> or <code>-ba</code>, which is equivalent to <code>-a -b</code>. </p>

<p>To achieve this kind of parsing use the <code>MultiFlag</code>.</p>
<pre class="highlight swift"><code><span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">MultiFlag</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
        <span class="kt">Flag</span><span class="p">(</span><span class="nv">shortName</span><span class="p">:</span> <span class="s">"a"</span><span class="p">)</span>
        <span class="kt">Flag</span><span class="p">(</span><span class="nv">shortName</span><span class="p">:</span> <span class="s">"b"</span><span class="p">)</span>
    <span class="p">])</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>Note that the mulit flag and all the added flags must have the same <code>shortPrefix</code> to get the expected result.</p>
<h4 id='automatic-help-flag' class='heading'>Automatic Help Flag</h4>

<p>If initializing <code>ArgTree</code> with a <code>description</code> or <code>helpText</code> a help flag
is automatically added, which will show a help text. 
A minimal example would be:</p>
<pre class="highlight swift"><code><span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">helpText</span><span class="p">:</span> <span class="s">"usage..."</span><span class="p">)</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>The call to the script with <code>-h</code> or <code>--help</code> passed as flag will print</p>
<pre class="highlight plaintext"><code>usage...
</code></pre>

<p>and exit afterwards.</p>

<p>If a <code>helpText</code> is passed it will simply be printed. 
Alternatively, a <code>description</code> can be passed, which will generate a 
help text from the description and all descriptions of the passed flags and 
options.</p>
<pre class="highlight swift"><code><span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span> 
<span class="s">"""
usage: </span><span class="se">\(</span><span class="kt">CommandLine</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="se">)</span><span class="s"> [flags...]

flags:
"""</span><span class="p">,</span> 
<span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"f"</span><span class="p">,</span> <span class="nv">description</span><span class="p">:</span> <span class="s">"a foo flag"</span><span class="p">),</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>This example will print</p>
<pre class="highlight plaintext"><code>usage: my_script [flags...]

flags:
--foo, -f a foo flag
</code></pre>
<h5 id='parse-order' class='heading'>Parse Order</h5>

<p>The generated help flag is always added as first parser to make sure it plays together with 
<a href="#varargs">Var Args</a> nicely. 
The order of the parsers can be changed after creation of the <code>ArgTree</code> object by manipulating its elements via the 
<code>MutableCollection</code> protocol (like an array). For example, to move the auto generated help flag parser to the end, do:</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">argTree</span> <span class="o">=</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">)</span>
<span class="n">argTree</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">argTree</span><span class="o">.</span><span class="nf">removeFirst</span><span class="p">())</span>
</code></pre>
<h5 id='default-action' class='heading'>Default Action</h5>

<p>Generated help is set as default action automatically. If this is not intended, the default action
can be unset or set to something else. </p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">argTree</span> <span class="o">=</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span> <span class="s">"usage..."</span><span class="p">)</span>
<span class="n">argTree</span><span class="o">.</span><span class="n">defaultAction</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="k">try!</span> <span class="n">argtree</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>
<h5 id='exit-after-help-printed' class='heading'>Exit After Help Printed</h5>

<p>The generated help flag parser always exits with code 0 after printing the help text. If this
is not the intended behaviour one can pass a closure, which is called after the help text is printed.
The following example shows how to continue without any specific action after printing help.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">argTree</span> <span class="o">=</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span> <span class="s">"usage..."</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* do nothing after help was printed */</span> <span class="p">}</span>
<span class="k">try!</span> <span class="n">argtree</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>
<h5 id='output-stream' class='heading'>Output Stream</h5>

<p>Help text is printed to <code>stdout</code> by default. This can be customized, by setting 
the <code>writeToOutStream</code> delegate. For example one could redirect the output to a string.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">argTree</span> <span class="o">=</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span> <span class="s">"usage..."</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">out</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">argTree</span><span class="o">.</span><span class="n">writeToOutStream</span> <span class="o">=</span> <span class="p">{</span> <span class="n">s</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<h3 id='option' class='heading'>Option</h3>

<p>An option is a key value property like <code>--foo=bar</code> or <code>--foo bar</code>. 
An option has a long and a short name, both are optional. 
Two syntaxes are supported, i.e. a key value pair can be passed separated by <code>=</code> or by passing the value as subsequent 
argument to the key. If the value to a key cannot be parsed, it will be reported as error 
(<code>OptionParseError.missingValueForOption</code>).
The following example shows the basic usage of options.</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"default"</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Option</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">)</span> <span class="p">{</span><span class="n">value</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">value</span><span class="p">}</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>
<h4 id='option-prefixes' class='heading'>Option Prefixes</h4>

<p>Prefixes can be changed as for flags, see <a href="#flag-prefixes">Flag Prefixes</a>.</p>
<h4 id='passing-an-option-multiple-times' class='heading'>Passing an Option Multiple Times</h4>

<p>Options can be passed multiples times, specifying different values. By default, passing an option multiple times
is reported as error (<code>OptionParseError.optionAllowedOnlyOnce</code>), 
as for flags, see <a href="#passing-a-flag-multiple-times">Passing a Flag Multiple Times</a>.
The following example shows how to implement an options, for which different values can be passed.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">fooOption</span> <span class="o">=</span> <span class="kt">Option</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">multiAllowed</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">fooOption</span><span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
<span class="n">fooOption</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">forEach</span><span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>

<p>In this case, it makes sense to handle the parsed options via <code>values</code> after parsing instead of handling them via
a closure. Although this is possible as well.</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Option</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">multiAllowed</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span> 
        <span class="n">foo</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>
<h4 id='int-option-and-double-option' class='heading'>Int Option and Double Option</h4>

<p>If only integers or floating point values are allowed for an option, 
the convenience parsers <code>IntOption</code> and <code>DoubleOption</code> can be employed. They work exactly like <code>Option</code> except 
that all values not parsable to an <code>Int</code> or <code>Double</code> will be reported as 
<code>OptionParseError.valueNotIntConvertible</code> or <code>OptionParseError.valueNotDoubleConvertible</code>, respectively.</p>
<h4 id='handling-unexpected-options' class='heading'>Handling Unexpected Options</h4>

<p>The mechanism is the same as for flags, see <a href="#handling-unexpected-flags">Handling Unexpected Flags</a>. 
Simply add a <code>UnexpectedOptionHandler</code> to the parsers.</p>
<h3 id='command' class='heading'>Command</h3>

<p>A command is a special argument to change control flow of the program. Simple scripts or programs like e.g. <code>rm</code> 
often do not have commands, more advanced command line programs, like. e.g. <code>git</code> support a variety of commands 
and even sub-commands.
The following example shows an implementation of a program, handling the command <code>foo</code>.</p>
<pre class="highlight swift"><code><span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">)</span> <span class="p">{</span> <span class="n">path</span> <span class="k">in</span> 
        <span class="cm">/* handle foo command */</span> <span class="p">}</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>When it comes to handling commands, quickly things get complicated. For example the following questions arise:</p>

<ul>
<li>Should a flag be supported only on the global level, or also on the level of each command?

<ul>
<li>For example, the <code>--verbose</code> flag might be supported on any level and have the same effect on any level, 
i.e. setting the output to verbose for the whole program.</li>
<li>The <code>--help</code> flag, on the other hand, might also be supported on every command, should however
print a different help for each command.</li>
<li>Additional flags should only be supported for certain commands and for others not.</li>
</ul></li>
<li>The same questions arises for options.</li>
<li>How are var args handled?

<ul>
<li>Some commands may take var args, others don&rsquo;t.</li>
</ul></li>
<li>Must var args be handled on the global level and also on the command level?</li>
<li>Can commands be nested?

<ul>
<li>If there exist commands, there should be also sub-commands and sub-sub-commands.</li>
</ul></li>
</ul>

<p>The good thing is, everything can be done with ArgTree. However, it requires a bit of an understanding, how
the parsing works, since the order in which parses are added to the parse tree matters.
To support finding out the correct order, consider to switch on logging while parsing, see <a href="#logging">Logging</a>.</p>

<p>Some of the cases listed above are detailed in examples in the following sections.</p>
<h4 id='global-flags-or-options' class='heading'>Global Flags (or Options)</h4>

<p>A global flag, that does the same for every command is easy to implement. Just add it before all commands.</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">verbose</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"verbose"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"v"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">)</span> 
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>The same can be done for options.</p>
<h4 id='semi-global-flags-or-options' class='heading'>Semi-Global Flags (or Options)</h4>

<p>A so called semi-global flag is one that can be set on any level, but has different effects. 
The following example shows how to implement a custom help flag, if the generated help should not be used.</p>
<pre class="highlight swift"><code><span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
        <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
            <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"help"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"h"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"help for foo"</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">])</span> 
        <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"help"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"h"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"global help"</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>The corresponding parse tree is</p>
<pre class="highlight plaintext"><code>argTree
  +-- foo
  |   +-- help(1)
  +-- help(2)
</code></pre>

<p>Here two differnt <code>Flag</code> instances (<code>help(1)</code> and <code>help(2)</code>) are employed to parse the help flags.</p>

<p>Instead of defining separate Flag instances, different actions can also be performed, based on the 
<a href="#parse-path">parse path</a>.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">help</span> <span class="o">=</span> <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"help"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"h"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">help</span><span class="p">])</span>
<span class="n">help</span><span class="o">.</span><span class="n">parsed</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">path</span><span class="o">.</span><span class="n">last</span> <span class="p">{</span>
        <span class="k">case</span> <span class="k">let</span> <span class="nv">cmd</span> <span class="k">as</span> <span class="kt">Command</span> <span class="k">where</span> <span class="n">cmd</span> <span class="o">===</span> <span class="nv">foo</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"foo help"</span><span class="p">)</span>
        <span class="c1">// case let cmd as Command where ...  (other commands)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"global help"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">help</span> <span class="n">foo</span><span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>By using the path, to determine the context of a flag, very generic implementations are possible. </p>

<p>The corresponding parse tree is</p>
<pre class="highlight plaintext"><code>argTree
  +-- foo
  |   +-- help
  +-- help
</code></pre>

<p>Which strategy is better depends on the use case. If the flag should have the same description on evey command, 
it might be better to use the same instance everywhere and implement the logic based on the path segment. 
On the other hand, the description is different for all commands, it might be simpler to use different instances.</p>
<h4 id='var-args-on-commands' class='heading'>Var Args on Commands</h4>

<p>For var args in general see <a href="#varargs">Var Args</a>. 
If var args should be passed to a specific command, it can be done simply by adding the var args on the command.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">fooVarArgs</span> <span class="o">=</span> <span class="kt">VarArgs</span><span class="p">()</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">fooVarArgs</span><span class="p">])</span> 
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>To add support for var args also on the global level, simply another var args object can be added at this level. 
It must be added after the command, otherwise the command will be parsed as var arg.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">globalVarArgs</span> <span class="o">=</span> <span class="kt">VarArgs</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">fooVarArgs</span> <span class="o">=</span> <span class="kt">VarArgs</span><span class="p">()</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">fooVarArgs</span><span class="p">]),</span>
    <span class="n">globalVarArgs</span><span class="p">,</span>
<span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>Look at some examples, how var args will be parsed in this case.</p>
<pre class="highlight shell"><code>my_script a b         <span class="c"># a and b parsed by globalVarArgs</span>
my_script foo a b     <span class="c"># a and b parsed by fooVarArgs</span>
my_script a foo b     <span class="c"># a parsed by globalVarArgs and b parsed by fooVarArgs</span>
</code></pre>

<p>This is straightforward, when looking a the parse tree.</p>
<pre class="highlight plaintext"><code>argTree
  +-- foo
  |   +-- globalVarArgs
  +-- fooVarArgs
</code></pre>
<h4 id='command-default-action' class='heading'>Command Default Action</h4>

<p>As on the root node <code>ArgTree</code> of the parse tree, there is an optional default action on each command. 
The default action is called, if no child parser consumed any further argument. 
The default action can be set on the command directly.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span> <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
        <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"bar"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"--bar parsed"</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">])</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> 
    <span class="nf">print</span><span class="p">(</span><span class="s">"foo (maybe also --bar parsed)"</span><span class="p">)</span> 
<span class="p">}</span>
<span class="n">foo</span><span class="o">.</span><span class="n">defaultAction</span> <span class="o">=</span> <span class="p">{</span> <span class="p">()</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"foo (--bar not parsed)"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">foo</span><span class="p">,</span> <span class="n">baz</span><span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>
<h4 id='code-parsed-code-and-code-afterchildrenparsed-code' class='heading'><code>parsed</code> and <code>afterChildrenParsed</code></h4>

<p>The command has two optional delegates: <code>parsed</code> and <code>afterChildrenParsed</code>.
The first, <code>parsed</code> is called, directly after the command was parsed, as for flags and options. At this time, 
however, no further arguments are parsed by parsers in the <code>parsers</code> property. 
The second delegate <code>afterChildrenParsed</code> is called, when the command was parsed and also all subsequent arguments
are parsed by parsers from the <code>parsers</code> property. So when a command is defined like in the following example</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">bar</span> <span class="o">=</span> <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"bar"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">bar</span><span class="p">])</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"bar?: </span><span class="se">\(</span><span class="n">bar</span><span class="o">.</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>the trailing closure refers to <code>afterChildrenParsed</code> and all parsed values from any child parser can be accessed.</p>
<h4 id='nested-commands' class='heading'>Nested Commands</h4>

<p><code>Commands</code>, <code>Flags</code>, <code>Options</code> and so on can be nested to arbitrary depth. 
This is why the package is called <code>ArgTree</code>. 
Here is a simple example.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">bar</span> <span class="o">=</span> <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"bar"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"foo bar"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span> <span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">foo</span><span class="p">])</span>
<span class="k">let</span> <span class="nv">baz</span> <span class="o">=</span> <span class="kt">Command</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"baz"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"baz"</span><span class="p">)</span> <span class="p">}</span>
<span class="n">foo</span><span class="o">.</span><span class="n">defaultAction</span> <span class="o">=</span> <span class="p">{</span> <span class="p">()</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"foo (no sub command)"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">try!</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="n">foo</span><span class="p">,</span> <span class="n">baz</span><span class="p">])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>Here is the parse tree.</p>
<pre class="highlight plaintext"><code>argTree
  +-- foo
  |   +-- bar
  +-- baz
</code></pre>
<h3 id='var-args' class='heading'>Var Args</h3>

<p>Var args are all arguments, that are not specifically parsed by any other parser. 
Quite often, a script takes an arbitrary number of files as var args. 
Consider the following example</p>
<pre class="highlight shell"><code>my_script <span class="nt">-v</span> file1 file2
my_script file1 file2 <span class="nt">--verbose</span>
</code></pre>

<p>Both scripts should process <code>file1</code> and <code>file2</code> as var args and handle <code>-v</code> or <code>--verbose</code> as flag, 
regardless of its position (to handle <code>-v</code> or <code>--verbose</code> as file, see <a href="#stop-token">Stop Token</a>). 
This can be achieved, by defining the following parse tree.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">varArgs</span> <span class="o">=</span> <span class="kt">VarArgs</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">argTree</span> <span class="o">=</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Flag</span><span class="p">(</span><span class="nv">longName</span><span class="p">:</span> <span class="s">"verbose"</span><span class="p">,</span> <span class="nv">shortName</span><span class="p">:</span> <span class="s">"-v"</span><span class="p">,</span> <span class="nv">description</span><span class="p">:</span> <span class="s">"verbose output"</span><span class="p">)</span> <span class="p">{</span> <span class="n">_</span> <span class="n">_</span> <span class="k">in</span> <span class="p">}</span>
    <span class="n">varArgs</span>
<span class="p">])</span>
</code></pre>

<p>As can be seen in the example, defining <code>VarArgs</code> inline, as for <code>Flag</code> is possible but does not make sense.
Notice that it is important to place <code>varArgs</code> after the <code>Flag</code>, otherwise every argument would be parsed as
var arg instead of parsing it as flag. So usually <code>VarArgs</code> is added last in the <code>parsers</code> array. 
Parsed var args are usually handled, after the parsing was completed via the <code>RandomAccessCollection</code> protocol 
(like an array).</p>
<pre class="highlight swift"><code><span class="k">try!</span> <span class="n">argTree</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
<span class="n">varArgs</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">forEach</span><span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<h3 id='handling-unexpected-arguments' class='heading'>Handling Unexpected Arguments</h3>

<p>If no var args are used, it might by helpful to report all errors as unexpected arg. 
In this case the <code>UnexpectedArgHandler</code> can be added as last parser. This will report any arg, not parsed by
another parser before as <code>ArgParseError.unexpectedArg</code>.</p>

<p>See also <a href="#handling-unexpected-flags">Handling Unexpected Flags</a> and 
<a href="#handling-unexpected-options">Handling Unexpected Options</a>.</p>
<h4 id='stop-token' class='heading'>Stop Token</h4>

<p>A stop token stops parsing subsequent arguments as they would normally be parsed. 
By default <code>--</code> is used as stop token. This means, all arguments passed after <code>--</code> will be parsed as var args.
This is helpful, if e.g. files with names that clash with a command or flag name should 
be passed as arguments. An example would be handling a file with name <code>-h</code></p>
<pre class="highlight shell"><code>my_script <span class="nt">--</span> <span class="nt">-h</span>
</code></pre>

<p>which would normally print the help text. In this case <code>-h</code> is treated as var arg, e.g. a file name.</p>
<h2 id='default-action' class='heading'>Default Action</h2>

<p>If no argument could be parsed, a default action can be performed. If there is a generated help flag, the default 
action will be set to printing the help text and exit. This can be customized by setting (or unsetting) a default 
action.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">argTree</span> <span class="o">=</span> <span class="kt">ArgTree</span><span class="p">()</span>
<span class="n">argTree</span><span class="o">.</span><span class="n">defaultAction</span> <span class="o">=</span> <span class="p">{</span> <span class="p">()</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"this is the default"</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>See also <a href="#command-default-action">Command Default Action</a>.</p>
<h2 id='error-handling' class='heading'>Error Handling</h2>

<p>The <code>parse</code> is supposed to throw errors on parsing the arguments. A variety of errors can be thrown and in simple 
scripts, it may be sufficient to force try the parse call (as in all examples in this document).
Any parse error will be reported to stderr and the program will exit. 
While this default behaviour is sufficient for simple scripts and programs, more suffisticated programs, might 
print nice error messages. This can be done by catching errors and doing some nice error handling.</p>
<pre class="highlight swift"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">try</span> <span class="kt">ArgTree</span><span class="p">(</span><span class="nv">parsers</span><span class="p">:</span> <span class="p">[</span><span class="kt">UnexpectedArgHandler</span><span class="p">()])</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">ArgParseError</span><span class="o">.</span><span class="nf">unexpectedArg</span><span class="p">(</span><span class="nv">argument</span><span class="p">:</span><span class="k">let</span> <span class="nv">arg</span><span class="p">,</span> <span class="nv">atIndex</span><span class="p">:</span><span class="n">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"got an unexpected argument: </span><span class="se">\(</span><span class="n">arg</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="k">let</span> <span class="nv">error</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"unknown error </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="nf">exit</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="p">}</span>

</code></pre>
<h2 id='logging' class='heading'>Logging</h2>

<p>To get a deeper understanding of why a certain argument is parsed or not parsed it can be very helpful to switch 
on logging.</p>

<p>Logging is done via the <a href="https://github.com/IBM-Swift/LoggerAPI">LoggerAPI</a>. So by default nothing is logged. 
To activate logging, one must configure a logger. A simple logger is e.g. 
<a href="https://github.com/IBM-Swift/HeliumLogger">HeliumLogger</a> which can be employed in the following way.</p>
<pre class="highlight swift"><code><span class="kd">import</span> <span class="kt">LoggerAPI</span>
<span class="kd">import</span> <span class="kt">HeliumLogger</span>
<span class="kt">Log</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="kt">HeliumLogger</span><span class="p">(</span><span class="o">.</span><span class="n">debug</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">argTree</span> <span class="o">=</span> <span class="kt">ArgTree</span><span class="p">()</span>
<span class="k">try!</span> <span class="n">argtree</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
</code></pre>

<p>Note that most of the logging is done on debug level, so this level should be activated to see any log output.</p>
<h2 id='architecture' class='heading'>Architecture</h2>

<p>The basic idead it so define a tree of parsers, which then consume argument after argument. This package helps to
define the parser tree and invoke it. Each node in the parser tree usually parses specific types of arguments, e.g. 
flags or options. To understand, how the parser tree must be set up, it is important to know how the tree is 
traversed. Consider the following example</p>
<pre class="highlight plaintext"><code>arguments = ['arg_0', 'arg_1', 'arg_2']
</code></pre>

<p>The first argument is always ignored, since it refers to the script name. Parsing is started at <code>arg_1</code>.
Now, if there is the following tree</p>
<pre class="highlight plaintext"><code>argTree
  +-- parser_0
  |   +-- parser_0_1
  +-- parser_1
</code></pre>

<p>first, <code>arg_1</code> will be parsed. Thereby <code>argTree</code> calls each child parser with the arguments array and the index <code>i</code>, 
where parsing should be done. 
Each child parser, <code>parser_0</code> and <code>parser_1</code> in this case can decidide to consume any number of arguments 
starting from <code>i</code> and returns how many arguments it consumed. Hence, if <code>parser_0</code> decides to consume all arguments,
<code>parser_1</code> will never get called, since there are no arguments left. If <code>parser_0</code> consumes no argument, <code>parser_1</code> get
called on the same index <code>i</code> and may also consume an arbitrary amount of arguments. 
For any index <code>i</code> calling subsequent child parsers is stopped, as soon as one child parser consumes a non-zero amount
of argumts. After that, the index <code>i</code> is incremented by the number of consumed arguments and the list of child parsers
ist iterated again from the beginning.
So if <code>parser_0</code> consumes <code>arg_1</code>, <code>parser_1</code> is not called. Instead <code>i</code> is incremented by one and <code>parser_0</code> is called
again for <code>arg_2</code>. So it is important to understand that parsers with low indices always have higher precedence 
than the following parsers. 
One corner case is, if an argument is not consumed by any parser. In this case <code>i</code> is incremented by one and the 
next argument is parsed. This means that the argument not parsed is simply ignored. If ignoring arguments is not 
the expected behaviour, an <code>UnexpectedArgHandler</code> can be added to throw an error. 
It should be clear now that the <code>UnexpectedArgHandler</code> must be added as last parser, since it simply consumes any
argument and converts it into an error.</p>

<p>Having understood the parsing process for one node, it is straightforward to understand the whole tree. Since every 
parser node can consume any number of arguments, it is not important how the node parses arguments. So each node
may can itself delegate to child parses in the described way. This makes it very easy to reuse simple parsers 
for flags and options. 
Here is a short example for a command line program, which takes a global flag <code>-v</code> and two commands <code>foo</code> and <code>bar</code>
which themselves take flags <code>-f</code> and <code>-b</code> respectively. </p>
<pre class="highlight plaintext"><code>argTree
  +-- -v
  +-- foo
  |   +-- -f
  +-- bar
      +-- -b
</code></pre>
<h3 id='parse-path' class='heading'>Parse Path</h3>

<p>To define the context of a parsed argument, a parse path is always specified. This is simply an array of parsers in 
the call chain. Note, that the root parser is not added to the path.
So for the following example </p>
<pre class="highlight plaintext"><code>argTree
  +-- -v
  +-- foo
  |   +-- -f
  +-- bar
      +-- -b
</code></pre>

<p>there would be the folowing paths when parsing</p>
<pre class="highlight plaintext"><code>[] : -v
[foo] : -f
[bar] : -b
</code></pre>

<p>This path can be used, if a parser should be used multiple times, but should act context aware. If e.g. <code>-v</code> should 
do something different for the <code>foo</code> and for <code>bar</code> the following tree should be defined</p>
<pre class="highlight plaintext"><code>argTree
  +-- foo
  |   +-- -v
  |   +-- -f
  +-- bar
      +-- -v
      +-- -b
</code></pre>

<p>Or, alternatively</p>
<pre class="highlight plaintext"><code>argTree
  +-- -v
  +-- foo
  |   +-- -v
  |   +-- -f
  +-- bar
      +-- -v
      +-- -b
</code></pre>

<p>if <code>-v</code> should also be supported on the global level. 
For an example on path specific actions see <a href="#semi-global-flags-or-options">Semi Global Flags (or Options)</a>.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2019 <a class="link" href="" target="_blank" rel="external"></a>. All rights reserved. (Last updated: 2019-12-01)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.12.0</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
